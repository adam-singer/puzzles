#!/usr/bin/env python
# ---------------------------------------------------------------------------- #

import sys
from thrift.transport import TTransport
from thrift.transport import TSocket
from thrift.transport import THttpClient
from thrift.protocol import TBinaryProtocol
from ttypes import *
import RushHour
from dijkstra import shortestPath, Dijkstra


START = 'I-START'
FINISH = 'I-FINISH'


def road_time(distance, speed):
    try:
        x = (float(distance) / float(speed))
    except ZeroDivisionError:
        return float(sys.maxint)
    else:
        return x


def next_intersection(roadmap,dist,src):
    road_to_take = None 
    cheapest = sys.maxint
    dst = src
    for intersection in roadmap.Intersections:
        for road in intersection.ConnectedRoads:
            start = road.StartIntersection
            end = road.EndIntersection
            if start == src:
                combined = dist[end] + road_time(road.Distance,road.CurrentSpeed)
                if combined < cheapest:
                    cheapest = combined
                    road_to_take = road            
                    dst = end
            elif end == src:
                combined = dist[start] + road_time(road.Distance,road.CurrentSpeed)
                if combined < cheapest:
                    cheapest = combined
                    road_to_take = road            
                    dst = start
            else:
                continue
    return road_to_take,road_to_take.CurrentSpeed,dst


def load(roadmap):
    g = {}
    for intersection in roadmap.Intersections:
        for road in intersection.ConnectedRoads:
            start = road.StartIntersection
            end = road.EndIntersection
            road_t = road_time(road.Distance,road.MaxSpeed)
            if start in g:
                g[start][end] = road_t
            else:
                g[start] = { end: road_t }
            if end in g:
                g[end][start] = road_t
            else:
                g[end] = { start: road_t }
    return g


host = "thriftpuzzle.facebook.com"
port = 9032

socket = TSocket.TSocket(host, port)
transport = TTransport.TBufferedTransport(socket)
protocol = TBinaryProtocol.TBinaryProtocol(transport)
client = RushHour.Client(protocol)
transport.open()

if not client.registerClient('mlbright@gmail.com', 'Martin-Louis Bright'):
    sys.stderr.write("WTF: Could not register.\n")
    sys.exit(1)

current = START
G = None
print current
while current != FINISH:
    roadmap = client.getRoadConditions()
    if not G:
        G = load(roadmap)
    dist,prev = Dijkstra(G,FINISH)
    road,speed,current = next_intersection(roadmap,dist,current)
    print "at time %.2f, road taken: %s" % (client.getTime(),current)
    client.takeRoad(road,speed)

#print client.winGame()
transport.close()
